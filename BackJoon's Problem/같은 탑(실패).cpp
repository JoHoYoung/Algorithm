//문제 1126 // 실패
//같은 탑
//홍준이는 N개의 직사각형 블록을 가지고 있다. 홍준이는 블록 위에 또다른 블록을
// 올려놓는 방식으로 탑을 만들 수 있다. 이때, 두 개의 탑을 만드는데, 이 두 탑의 높이가
// 같게 만드려고 한다. (각 탑은 적어도 한 개의 블록을 포함해야 한다) 홍준이는 되도록이면 탑의
// 높이를 최대로 하려고 한다. 그리고 모든 블록을 사용할 필요는 없다.
//
//각 블록의 높이가 주어질 때, 홍준이가 만들 수 있는 탑의 높이의 최댓값을 출력하는 프로그램을 작성하시오.


// 제일큰것을 한쪽에 놓는다
// 그다음 큰것을 같은쪽에 놓는다
// 그다음 큰것을 반대쪽에 놓는다.

// DP[i][j]....
// i번쨰 토막을 포함하지 않는다면 DP[i][j] = DP[i-1][j];
// i번째 토막을 포함한다면 왼쪽 or 오른쪽
// 왼쪽 DP[i][j] = DP[i-1][j+h[i]]
// 오른쪽 DP[i][j] = DP[i-1][j+h[i]]

// 절반이 나오려면
//...실패
// 논리의 흐름
// dp[i][j]=1~ i번 토막으로 높이가 h1,h2이고 h1−h2=j인 탑을 만들었을 때 h1의 최댓값
//
//(단, h1>=h2>=0)

//i번째 토막을 포함하는경우 / 포함하지 않는 경우로 나누면 위 점화식을 해결할 수 있다.

//dp[i][j]를 계산하는 상황을 생각해보자.
//i 번째 토막을 포함하지 않는다면 dp[i][j]=dp[i−1][j]이다.
//i번째 토막을 포함한다면 h1에 포함되는 경우와, h2에 포함되는 경우로 나눌 수 있다.
//
//먼저 h2에 포함되는 경우 dp[i][j]=dp[i−1][j+h[i]]이다.
//
//h1에 포함되는 경우는 다시 두 경우로 나뉜다.
//
//
//h[i]<=j인 경우, dp[i][j]=dp[i−1][j−h[i]]+h[i]이다.
//h[i]>j인 경우, dp[i][j]=dp[i−1][h[i]−j]]−(h[i]−j)+h[i]=dp[i−1][h[i]−j]]+j이다.

//위 세 가지 경우들 중 최댓값을 dp[i][j]로 정하면 된다.

//최종적으로, dp[n][0]은 n개의 토막을 고려하여 h1−h2=0, 즉 h1=h2인 최대의 h1을 담게 된다.

//dp[n][0]=0일 경우 h1=h2=0이므로 탑을 쌓는 것이 불가능하다. 따라서 0인지 아닌지 판단하여 -1이나 최대 높이를 출력하면 된다.

//다만 점화식을 계산할 때 주의할 점은, '존재할 수 없는 경우'를 제외시켜야 한다는 것이다. (dp[i][j]=0인 것과는 다르다. 이는 '아무것도 선택하지 않는 경우'에 해당한다.)

//이를테면 초기 조건에서 dp[0][0]=0이지만, dp[0][i](i>=1)은 존재하지 않는다.

//따라서 음수 등 다른 dp값과 구별되는 값으로 지정할 필요가 있다

#include<iostream>
#include<cstring>
#include<algorithm>

long DP[50][]
using namespace std;


int main()
{

    int sum = 0;
    int pivot;

    int N;
    cin>>N;

    int Arr = new int[N];

    for(int i=0;i<N;i++)
    {
        cin>>Arr[i];
        sum += Arr[i];
    }
    sort(Arr,N);

    for(int i=0;i<)








    return 0;
}