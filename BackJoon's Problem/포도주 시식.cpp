//문제 2156 포도주 시식
//효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있
// 는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.
//
//포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
//연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
//효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주
// 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포
// 도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의
// 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.
//
//예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1
// 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을
// 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

//뒤에서부터 가는 식.
// n을 선택했을때 2개연속째인경우 아닌경우.
// n번째 잔을 선택
// -> 1. n-1번째 잔을 선택 -> 2개 연속째인 경우
// -> 2. n-2번째 잔을 선택. -> 아닌 경우
// 어떤 경우던 n-1을 고르면 n-2를 고를 수 없다. n-1이나 n-2 둘중 하나를 골라야 한다.
// n-1을 고를때는 이미 2개 연속째가 아니어야 한다.
// n번째 잔을 고를 수 있다 -> n+1잔을 고르지 않았다. n+1잔을 골랐으나 n+2잔은 고르지 않았다.

// 두개로 나누자. n번째잔을 고른 경우, 안고른 경우.
// n번째 고른것이 -> n+1잔을 골랐을 케이스, 아닐 케이스.
// n번째를 고른다. 그게 2개연속일 경우 / 독립일경우. 의 최대. 2개연속 -> 앞에거가 독립일경우 최대에 더해준다.
// 독립일경우 -> 앞에거 고른게 3개연속, 앞에거를 그냥 안고름. 일단 앞에거를 안골라야 하니. n-2번째의 최대값.
//DP2[n]=DP1[n-1]+Arr[n];
//DP1[n]=Max(DP1[n-2],DP2[n-2])+Arr[n];
#include<iostream>
using namespace std;

long DP[10003];
long DP0[10003];
long DP1[10003];   // n번째의 연속 .
long DP2[10003];   // n번째의 독립.

int Max(int a,int b)
{
    if(a>b)
        return a;
    else return b;

}

int main()
{
    int N;
    cin>>N;
    int *Arr;
    Arr=new int[N];
    for(int i=0;i<N;i++)
        cin>>Arr[i];

    DP0[0]=0;
    DP1[0]=Arr[0];
    DP2[0]=0;

    DP0[1]=Arr[0];
    DP1[1]=Arr[1];
    DP2[1]=Arr[0]+Arr[1];
    long max=Arr[0]+Arr[1];
    for(int i=2;i<N;i++)
    {
        DP0[i]=Max(DP0[i-1],Max(DP1[i-1],DP2[i-1]));
        DP1[i]=DP0[i-1]+Arr[i];
        DP2[i]=DP1[i-1]+Arr[i];
        DP[i]=Max(DP0[i],Max(DP1[i],DP2[i]));

        if(DP[i]>max)
            max=DP[i];
    }


    cout<<max;
    return 0;
}