//문제 2157 여
//N개의 도시가 동쪽에서 서쪽으로 순서대로 위치해 있다. 제일 동쪽에 있는 도시는 1번
// 도시이며, 제일 서쪽에 있는 도시는 N번 도시이다.
//
//당신은 이와 같은 도시 중에서 M개 이하의 도시를 지나는 여행을 계획하려 한다.
// 여행 경로는 반드시 1번 도시에서 시작해서 N번 도시에서 끝나야 한다.
// 물론 이 두 도시도 M개의 도시에 포함된다. 당신은 시차에 매우 민감하기 때문에,
// 한 번 서쪽으로 이동했다가 다시 동쪽으로 이동하면 몸이 대단히 아프다. 그래서
// 당신은 계속 서쪽으로만, 즉 도시 번호가 증가하는 순서대로만 이동하기로 하였다.
//
//한편, 모든 도시에서 다른 모든 도시로 이동할 수 있는 건 아니다. 각각의
// 도시에서 다른 도시로 이동할 때에는 비행기를 타고 이동해야 하는데, 때로는
// 비행 항로가 개설되지 않았을 수도 있다. 또한 당신은 비행기를 아무렇게나
// 타려는 것이 아니라, 최대한 맛있는 기내식만 먹으면서 이동하려 한다(사실 이게 여행의 목적이다).
//
//항로 개설 여부와 해당 항로에서 제공되는 기내식의 점수가 주어졌을 때,
// 먹게 되는 기내식의 점수의 총 합이 최대가 되도록 하시오.

//N은 도시의 갯수 M은 방문할수 있는 최대 도시 수 K는 항공로의 갯수
#include<iostream>

using namespace std;
int Node[100001][3];
int Root[301][301];
int DP[301][301];
//DP[N][M] N번 나라까지 M번 경유하여 가는 수.

int Max(int a,int b)
{
    if(a>b)
        return a;
    else return b;
}
//Root[N][M] ->  N번출발 M번도착의 값어치
int main() {

    // 1~N까지 도시의 번호 존재함
    int N,M,K;

    cin>>N>>M>>K;

    for(int i=1;i<=300;i++)
        for(int j=1;j<=300;j++)
            Root[i][j]=0;

    for(int i=0;i<K;i++)
    {
        cin>>Node[i][0];
        cin>>Node[i][1];
        cin>>Node[i][2];  //0은 출발 1은 도착 2는 값어치

        if(Root[Node[i][0]][Node[i][1]]<Node[i][2])
            Root[Node[i][0]][Node[i][1]]=Node[i][2];
    } // 중복되는 경로 제외, 가치가 제일 큰 경로 Root[N][M]에 저장. N에서 출발하여 M에서 도착하는 경로이며 그의
            //값어치

                    for(int i=0;i<301;i++)
                        for(int j=0;j<301;j++)
                            DP[i][j]=0;
    //M번 , 출발 도착 빼면 M-2번
    for(int i=2;i<=N;i++)
    {
     //   cout<<"도착지 : "<<i<<" "<<endl;
        for(int j=1;j<=M;j++)
        {
       //     cout<<j<<" 번 경유하는 경우"<<endl;
            //i번 나라까지 j번 경유하여 가는 경우 는......
                    for(int k=1;k<i;k++) {
                        if(j==1)
                        {
                            DP[i][j]=Root[1][i];
         //                   cout<<"는 "<<DP[i][j]<<" 가 저장됐다."<<endl;
                        }
                        else
                        {if(DP[i-k][j-1]!=0&&Root[i-k][i]!=0) {
                                DP[i][j] = Max(DP[i][j], DP[i - k][j - 1] + Root[i - k][i]);

           //             cout<<DP[i-k][j-1]<<" 에"<<Root[i-k][i]<<"를 더했다 루트의 변수는"<<i-k<<" 랑 "<<i<<" 다 ."<<endl;

                        }
                        else{
 //                           DP[i][j]=-10000;
                        }
                        //i-k번 나라까지 j-1번 경유하는 경우 + i-k번 나라부터 j번 나라까지 값어치
                    }
                    }
        }

    }
    //DP[N][M] : N번의 도시까지 M번 경유 했다는것. M번경유했다는것 : M+1개의 도시를 들렀다는 것.
//j번 경유 한다는 것 : j+1개의 도시를 들렀다는것
    int max=-10000;

   for(int i=1;i<=M-1;i++)
        if(max<DP[N][i])
            max=DP[N][i];
//
//    for(int i=1;i<=M-1;i++)
//        cout<<DP[N][i]<<endl;

            cout<<max;
    return 0;
}