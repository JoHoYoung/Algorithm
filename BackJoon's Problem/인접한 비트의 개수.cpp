//문제 2698
//0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다.
// S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.
//
//s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn
//
//위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어,
// 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.
//
//수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인
// 수열 S의 개수를 구하는 프로그램을 작성하시오.
//
//예를 들어, n이 5이고, k가 2이면, 수열 S가 될 수 있는
// 수열은 다음과 같이 6가지가 있다.
//
//11100, 01110, 00111, 10111, 11101, 11011

#include<iostream>
using namespace std;

//3개가 이어진것은 2개.
//n개의 1이 이어진것은 n-1개이다.
//음... k개 중에서 .. 나눠서 앞에는 i개. 뒤에는 k-i개로 보면 합치면 1이고. 부분으로 나누느것은 0으로 구분.
//DP[n][k]= DP[n-a][i] + DP[a-1][k-i] 로 코딩하면 되겠다. 부분을 나누고, 중간은 0으로 구별해야 하니까 n-a, a-1이
//부분들의 갯수가 됨.
//위의 방법은 아닌거 같다. DP[n][k]는 DP[n-1][k-1]중에서 .....1로 끝나는걸 더하면 된다.
//....1로 끝나는건 DP[n-2][k-2]+...모르겠다.
//1. 맨 마지막이 0인경우와 맨마지막이 1인경우가 있다.
//  -맨 마지막이 0인경우
//    앞에거 1로 끝나는거 + 앞에거 0으로 끝나는거.
//  -맨 마지막이 1인경우
//    앞에거 k-1개, 1로 끝나는거, 앞에거 k개, 0으로 끝나는거.
//  DP1[n][k]=DP1[n-1][k-1]+DP0[n-1][k];
//  DP0[n][k]=DP1[n-1][k]+DP0[n-1][k];

int DP0[101][100];  //n이 100까지이고 그럼 k는 많아봐야 99개이므로 101*100으로 선언.
int DP1[101][100];

int main()
{

    int N;
    cin>>N;
    long result[N];
    int dex=0;
    for(int q=0;q<N;q++)//테스트케이스 수 즉 N번만큼 수행
    {
        int n,k;
        cin>>n;
        cin>>k;

        for(int i=1;i<=n;i++)
            for(int j=0;j<=i-1;j++)
            {
                if(i==1&&j==0) {
                    DP0[i][j] = 1;
                    DP1[i][j] = 1;
                }
                else {
                    DP1[i][j] = DP1[i - 1][j - 1] + DP0[i - 1][j];
                    DP0[i][j] = DP1[i - 1][j] + DP0[i - 1][j];
                }

            }
        result[dex++]=DP0[n][k]+DP1[n][k];

    }
    for(int i=0;i<N;i++)
        cout<<result[i]<<endl;

    return 0;
}